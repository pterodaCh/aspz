# README

## Завдання

Реалізуйте фрагмент коду, який зчитує за межами виділеного масиву без явного порушення доступу — і поясніть, чому це можливо.


## Виконання. Вихід за межі та невизначена поведінка

### Приклад 1
Мови C та C++ відомі тим, що дуже велика частина роботи з цими мовами закінчується кінцем мапи із надписом hic sunt dracones. Якщо без усіляких жартів, отримати у своєму коді невизначену поведінку доволі просто. 

Порушення меж масиву можливе і може призвести до різних наслідків. Оскільки доступ до масивів завжди здійснюється через вказівники, цей доступ зазвичай не перевіряється на відповідність розміру надіючись на компетенцію програміста, хоча деякі компілятори можуть надавати перевірку меж як опцію. 

Крім того комітет зі стандартів залишив багато речей невизначеними з наміром і сподіванням, що люди, які хочуть продавати компілятори, визначатимуть поведінку крайніх випадків поза межами стандарту, якщо це буде корисно для їхніх клієнтів.

У формі приклада було використано такий фрагмент коду
```
enum {N=32};
int a[N], pfx[N];
void prefix_sum()
{
    int i, accum;
    for (i=0, accum=a[0]; i < N; i++, accum+=a[i])
    pfx[i] = accum;
}
```
Проведімо компіляцію програми
```
gcc -Wall outofbound3.c -o outofbound3
```
![image](https://github.com/user-attachments/assets/99d5392e-bb60-4377-9ed8-2c6b154c4d5f)

Як бачимо компіляція пройшла успішно, проте невизначеність тут є.

Для того, щоб GCC компілятор повідомив нам про неї знадобиться використати оптимізатори. 
Без жодних оптимізацій(`-O0` є значення за замовчуванням), мета компілятора - зменшити вартість компіляції та зробити так, щоб налагодження давало очікувані результати. Увімкнення прапорів оптимізації змушує компілятор намагатися покращити продуктивність та/або розмір коду за рахунок часу компіляції і, можливо, можливості налагодження програми.

Для наших потребу достатньо буде прапорця  `-O2`. Він оптимізує набагато більше ніж `-O1`. За його використання GCC виконує майже всі підтримувані оптимізації, які не потребують компромісу між швидкістю та простором. Детальніше про оптимізацію [ось тут](https://gcc.gnu.org/onlinedocs/gcc-3.3.2/gcc/Optimize-Options.html#Optimize%20Options)

Компіляція із оптимізацією
```
gcc -O2 -Wall outofbound3.c -o outofbound3
```
![image](https://github.com/user-attachments/assets/a6832be3-93f1-430c-8fc1-b9bf19efb10a)

Крім виходу за межі, цей фрагмент коду є певним аргументом проти дуже стислого стилю циклу for, який надає мова C, що робить невизначену поведінку складнішою для сприйняття, ніж вона могла б бути. 

### Приклад 2

Блукаючи форумами, що порушують питання невизначеної поведінки на трапила на [лекцію професора Джеррі Кейна про парадигми програмування (CS107) від Стенфордського університету](https://youtu.be/ucQI5HpiFrI?si=MENnBiVJZf_HNcTP&t=2566)

Він запропонував такий фрагмент коду на розгляд
```
int main()
{
    int i;
    int array[4];
    for(i = 0; i <= 4; i++)
    {
        array[i] = 0;
    }
    return 0;
}
```
