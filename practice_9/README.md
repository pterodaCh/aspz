# Практика 9
## Завдання 1
 Напишіть програму, яка читає файл /etc/passwd за допомогою команди getent passwd, щоб дізнатись, які облікові записи визначені на вашому комп’ютері.
 Програма повинна визначити, чи є серед них звичайні користувачі (ідентифікатори UID повинні бути більші за 500 або 1000, залежно від вашого дистрибутива), окрім вас.
##
Програма користувачів системи, виконуючи команду getent passwd і фільтруючи звичайних користувачів. Вона починає з ідентифікації поточного користувача за допомогою системних викликів getuid() і getpwuid(), потім відкриває канал для запуску getent passwd, який отримує всю інформацію про обліковий запис користувача з бази даних користувачів системи через /etc/passwd. Програма аналізує кожен рядок виводу, токенізуючи поля, розділені двокрапкою, що представляють ім'я користувача, пароль-заповнювач, UID, GID, повне ім'я, домашній каталог і оболонку. Він фільтрує звичайних користувачів, перевіряючи, чи їхній UID дорівнює 1000 або більше, виключаючи поточного користувача з результатів.
Було організовано приємний вивід результату, де для кожного знайденого користувача програма показує його ім'я користувача, UID, справжнє ім'я з поля GECOS і домашній каталог.

![image](https://github.com/user-attachments/assets/0be70002-a055-4d6e-9241-1d2cd3d03730)

## Завдання 2
 Напишіть програму, яка виконує команду cat /etc/shadow від імені адміністратора, хоча запускається від звичайного користувача.
 (Ваша програма повинна робити необхідне, виходячи з того, що конфігурація системи дозволяє отримувати адміністративний доступ за допомогою відповідної команди.)

##
Оскільки переважно я працюю із root мені потрібно було перенести файли до користувача ptero з якого відбувалося б тестування програми. Тому файл потрібно було б перемістити.
```
cp aspz/practice_9/2 /home/ptero/2
```
Далі щоб дозволити ptero запустити програму потрібно надати права доступу
```
chown root:wheel /home/ptero/2
chmod 4755 /home/ptero/2
```

Перевіряємо
```
ls -l 2
```

![image](https://github.com/user-attachments/assets/1116ad2f-057a-446c-8cee-ed215756f324)

залишилося залогінитися як користувач ptero та запустити програму з дикректорії куди ми скопіювали файл. Як бачимо, усе працює
![image](https://github.com/user-attachments/assets/7bcf1355-16eb-40fb-9b58-b173c7a8ae4f)

## Завдання 3
 Напишіть програму, яка від імені root копіює файл, який вона перед цим створила від імені звичайного користувача. Потім вона повинна помістити копію у домашній каталог звичайного користувача.
 Далі, використовуючи звичайний обліковий запис, програма намагається змінити файл і зберегти зміни. Що відбудеться?
 Після цього програма намагається видалити цей файл за допомогою команди rm. Що відбудеться?
##
Виконання задачі було розділене на два файли. Перший запускається від імені root, створює файл у /aspz/practice_9/original.txt, копіює його у /home/ptero/backup.txt і змінює власника. Друга виконується користувачем ptero, намагається змінити та видалити файл, щоб перевірити, які операції дозволені звичайному користувачу з файлами, створеними root.

![image](https://github.com/user-attachments/assets/ba3657bf-fc7f-45d4-9e65-371b25eb86e7)

![image](https://github.com/user-attachments/assets/df79cc0a-cb17-4911-8fb7-f025ee45ffd9)


## Завдання 4
 Напишіть програму, яка по черзі виконує команди whoami та id, щоб перевірити стан облікового запису користувача, від імені якого вона запущена.
 Є ймовірність, що команда id виведе список різних груп, до яких ви належите. Програма повинна це продемонструвати.

##
Для виконання завдання, а саме: визначення користувача і груп до яких він належить - можна використати команди `whoami` і `id`. 
`whoami` Виведе який користувач екзекютить програму, а `id` виводить імена користувачів і груп, а також числові ідентифікатори процесу.  Якщо реальний та ефективний ідентифікатори відрізняються, виводяться обидва, інакше виводиться лише реальний ідентифікатор.

![image](https://github.com/user-attachments/assets/dfc46770-9ef3-4c3f-ab36-d260cf5c8ec1)

## Завдання 5
 Напишіть програму, яка створює тимчасовий файл від імені звичайного користувача. Потім від імені суперкористувача використовує команди chown і chmod, щоб змінити тип володіння та права доступу.
 Програма повинна визначити, в яких випадках вона може виконувати читання та запис файлу, використовуючи свій обліковий запис.
##
Перш за все створюється тимчасовий файл за допомогою функції `mkstemp`. Вона генерує унікальне ім’я файлу в директорії /tmp і відкриває його для запису. Після успішного створення у файл записуються тестові дані, і файл закривається. Далі програма викликає функцію check_access, яка Було створено функцію `check_access` для перевірки доступів поточного користувача. У даному випадку це читання та запис файлів. 

Якщо програма запущена з привілеями root (перевіряється через geteuid()), вона намагається знайти користувача з іменем nobody за допомогою getpwnam. Якщо такий користувач знайдений, файл перепризначається на нього (зміна UID і GID власника) через chown. Потім змінюються права доступу до файлу на 0640. Це дозволяє користувачу читати й писати. Після цього ще раз викликається check_access

Якщо ж  немає root-доступу виводиться повідомлення про те, що зміна власника і прав пропускається. 
Результат виконання програмі при запуску її звичайним користувачем

![image](https://github.com/user-attachments/assets/51df18f5-e9d7-4e47-ab7d-fcbc85375599)

Та якщщо це з робити з root

![image](https://github.com/user-attachments/assets/b5337e9a-4181-434f-b745-af1757c8a212)

## Завдання 6
Напишіть програму, яка виконує команду ls -l, щоб переглянути власника і права доступу до файлів у своєму домашньому каталозі, в /usr/bin та в /etc. Продемонструйте, як ваша програма намагається обійти різні власники та права доступу користувачів, а також здійснює спроби читання, запису та виконання цих файлів.
##

Прграма визначає доступ до файлів у трьох різних каталогах файлової системи 
- домашньому каталозі користувача ($HOME)
- системному каталозі з виконуваними файлами (/usr/bin)
- каталозі конфігураційних файлів (/etc)
  
Спочатку виконується команда ls -l, щоб показати список файлів у кожному з цих каталогів разом із правами доступу, власником і групою.
Потім відкривається кожен каталог із намаганням знайти файли, щоб на них перевірити доступи до 3ьох дій, що може виконати користувач, а саме: читати, писати та виконати файл. Для цього використовується функція access(), яка дозволяє визначити, чи доступна певна дія над файлом з урахуванням UID/GID процесу.

![image](https://github.com/user-attachments/assets/fb3b4c9b-4eeb-4d4e-92af-75451fd0287a)

![image](https://github.com/user-attachments/assets/4b8afbb9-585b-4669-bc9f-62b350a66fa1)

![image](https://github.com/user-attachments/assets/4cba8e82-b3b7-4361-8f26-21391a0ca310)

![image](https://github.com/user-attachments/assets/9021095c-32f7-4d62-baab-abf4ddd408d5)
## Завдання 7
Створіть систему, де обмежується доступ до певного файлу лише в певні години. Які інструменти можна використати?
##

У цій прграмі було використано стандартну бібліотеку time.h для отримання локального часу. Для виконання завдання потрібно перевірити та порівняти поточний час із заданим інтервалом.
Якщо доступ дозволено, файл відкривається для читання, і
його вміст виводиться на екран. 
Порівняння виконує ця функція `is_access_allowed()`

У програмі задано макрозміними час, коли користувач має доступ до файлу. Зараз на годинику 2:32 (АМ). Тож перевіремо, що ми отримаємо в терміналі
```
#define START_HOUR 9
#define END_HOUR 17
```

![image](https://github.com/user-attachments/assets/c8c576e5-43ef-483d-a6f1-4decd08f8d19)

Як бачимо доступ до файлу "secret.txt" відхилено через неспівпадіння інтервалу часу. Пропоную в коді замінити це на нічний час, щоб "сови" змогли побачити вміт.

```
#define START_HOUR 1
#define END_HOUR 5
```
![image](https://github.com/user-attachments/assets/ca3663c1-b090-4e15-84d4-b5bd5d8a3bf7)

Завдання виконано, користувач може бачити або не бачити вміст файлу в залежності від заданого часового проміжку.
