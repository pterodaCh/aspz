
# Практика 8
## Завдання 1

Чи може виклик count = write(fd, buffer, nbytes); повернути в змінній count значення, відмінне від nbytes? Якщо так, то чому? Наведіть робочий приклад програми, яка демонструє вашу відповідь.
## 
Згідно з документацією freebsd системний виклик write(int fd, const void	*buf, size_t nbytes) намагається записати n байт даних в об'єкт на який посилається дескриптор fd з буферу, на який вказує buf. Як і зазначається у завданні, при успішному завершені виклику повинна повертатися кількість байт, що була записана. А з цього моменту починаються нюанси. Наприклад, при використанні неблокуючого вводу/виводу на таких об'єктах, як сокети або канали, які підлягають контролю потоку write() здатна записати менше байт, ніж було запитано. Або ж, на дисковому пристрої недостатньо місця для запису всього запитуваного байта! Тоді наступний виклик або передасть додаткові байти, або
може призвести до помилки.

Інші можливі причини виникнення помилки:
* Аргумент fd не є допустимим дескриптором, відкритим для запису
* Зроблено спробу записати у канал, що не відкритий для читання жодним процесом
* Здійснюється спроба запису в сокет типу SOCK_STREAM, який не підключено до однорангового сокету
* Вказівник, пов'язаний з fd, був від'ємним
* Файл було позначено для неблокуючого вводу/виводу, і жодні дані не могли бути записані негайно
* Значення nbytes більше за SSIZE_MAX (абобільше INT_MAX, якщо в sysctl debug.iosize_max_clamp не дорівнює нулю)

На мою думку, завдання пропонує створити ситуацію коли повернуться менша кількість nbytes. Ми можемо застосувати функцію [`fcntl()`](https://man.freebsd.org/cgi/man.cgi?query=fcntl&apropos=0&sektion=0&manpath=FreeBSD+7.2-RELEASE&format=html) із прапорцем `O_NONBLOCK`, який забезпечує неблокуючий ввід/вивід, та використати канали

## Завдання 2
Є файл, дескриптор якого — fd. Файл містить таку послідовність байтів: 4, 5, 2, 2, 3, 3, 7, 9, 1, 5. У програмі виконується наступна послідовність системних викликів:
lseek(fd, 3, SEEK_SET);
read(fd, &buffer, 4);
де виклик lseek переміщує показник на третій байт файлу. Що буде містити буфер після завершення виклику read? Наведіть робочий приклад програми, яка демонструє вашу відповідь.

## 
Системний виклик lseek() зміщує зміщення дескриптора файлу на зміщення аргументу відповідно до директиви whence.  Аргумент має бути відкритим дескриптором файлу.  Системний виклик lseek()змінює позицію вказівника на файл, пов'язаного з дескриптором файлу наступним чином
* SEEK_SET - зміщення (offset) встановлюється на offset байтів від початку файлу.
* SEEK_CUR - зміщення встановлюється на поточну позицію плюс offset байтів.
* SEEK_END - зміщення встановлюється на розмір файлу плюс offset байтів.
* SEEK_HOLE - зміщення встановлюється на початок наступного "дірки", що знаходиться на позиції не менше заданого offset.

«Дірка» визначається як нерозривний діапазон байт у файлі, всі з яких мають нульове значення, але не гарантується, що всі нулі
нульове значення, але не всі нулі у файлі гарантовано будуть
представлені як дірки, що повертаються з SEEK_HOLE. 
За умовою завдання цей фрагмент перемістить показник на третій байт файлу fd.

```
lseek(fd, 3, SEEK_SET)
```

І читає наступні 4 байти.

```
read(fd, &buffer, 4)
```

Таким чином ми отримуємо наступний результа:

![image](https://github.com/user-attachments/assets/89dcdf71-b6d3-4616-9923-7cf369094c32)

## Завдання 3 (Дуже цікаве завданння приділити більше часу коли приїду)
Бібліотечна функція qsort призначена для сортування даних будь-якого типу. Для її роботи необхідно підготувати функцію порівняння, яка викликається з qsort кожного разу, коли потрібно порівняти два значення.
Оскільки значення можуть мати будь-який тип, у функцію порівняння передаються два вказівники типу void* на елементи, що порівнюються.
Напишіть програму, яка досліджує, які вхідні дані є найгіршими для алгоритму швидкого сортування. Спробуйте знайти кілька масивів даних, які змушують qsort працювати якнайповільніше. Автоматизуйте процес експериментування так, щоб підбір і аналіз вхідних даних виконувалися самостійно.
Придумайте і реалізуйте набір тестів для перевірки правильності функції qsort.

## 

## Завдання 4
Виконайте наступну програму на мові програмування С:
int main() {
іnt pid;
pid = fork();
printf("%d\n", pid);
}
Завершіть цю програму. Припускаючи, що виклик fork() був успішним, яким може бути результат виконання цієї програми?

## 

![image](https://github.com/user-attachments/assets/d1fe539e-939d-4e8c-9c27-a9071fe93a41)

## Завдання 5
Реалізуйте інтерпретатор команд, який підтримує черги читання-запису між процесами через pipe, не використовуючи shell.
## 
```
ls -l
```

![image](https://github.com/user-attachments/assets/26959f87-0f83-48af-bb8f-7b87dab3c75e)

```
nano a.txt
```

![image](https://github.com/user-attachments/assets/67c32581-b5f1-4aa1-831e-f16a7cd9fadc)

```
uname -r
mkdir aaaaaaaa
```
![image](https://github.com/user-attachments/assets/d339fe0f-efaf-4ee3-b365-037965c5ba82)

```
./task5
exit
```

![image](https://github.com/user-attachments/assets/4220a11c-629b-46c2-9c9a-bf7c7ac41bef)

