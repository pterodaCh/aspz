
# Практика 8
## Завдання 1

Чи може виклик count = write(fd, buffer, nbytes); повернути в змінній count значення, відмінне від nbytes? Якщо так, то чому? Наведіть робочий приклад програми, яка демонструє вашу відповідь.
## 
Згідно з документацією freebsd системний виклик write(int fd, const void	*buf, size_t nbytes) намагається записати n байт даних в об'єкт на який посилається дескриптор fd з буферу, на який вказує buf. Як і зазначається у завданні, при успішному завершені виклику повинна повертатися кількість байт, що була записана. А з цього моменту починаються нюанси. Наприклад, при використанні неблокуючого вводу/виводу на таких об'єктах, як сокети або пайпи, які підлягають контролю потоку write() здатна записати менше байт, ніж було запитано. Або ж, на дисковому пристрої недостатньо місця для запису всього запитуваного байта! Тоді наступний виклик або передасть додаткові байти, або
може призвести до помилки.

Інші можливі причини виникнення помилки:
* Аргумент fd не є допустимим дескриптором, відкритим для запису
* Зроблено спробу записати у пайп, що не відкритий для читання жодним процесом
* Здійснюється спроба запису в сокет типу SOCK_STREAM, який не підключено до однорангового сокету
* Вказівник, пов'язаний з fd, був від'ємним
* Файл було позначено для неблокуючого вводу/виводу, і жодні дані не могли бути записані негайно
* Значення nbytes більше за SSIZE_MAX (абобільше INT_MAX, якщо в sysctl debug.iosize_max_clamp не дорівнює нулю)

На мою думку, завдання пропонує створити ситуацію коли повернуться менша кількість nbytes. Ми можемо застосувати функцію [`fcntl()`](https://man.freebsd.org/cgi/man.cgi?query=fcntl&apropos=0&sektion=0&manpath=FreeBSD+7.2-RELEASE&format=html) із прапорцем `O_NONBLOCK`, який забезпечує неблокуючий ввід/вивід, та використати пайпи

## Завдання 2
Є файл, дескриптор якого — fd. Файл містить таку послідовність байтів: 4, 5, 2, 2, 3, 3, 7, 9, 1, 5. У програмі виконується наступна послідовність системних викликів:
lseek(fd, 3, SEEK_SET);
read(fd, &buffer, 4);
де виклик lseek переміщує покажчик на третій байт файлу. Що буде містити буфер після завершення виклику read? Наведіть робочий приклад програми, яка демонструє вашу відповідь.

## 

## Завдання 3
Бібліотечна функція qsort призначена для сортування даних будь-якого типу. Для її роботи необхідно підготувати функцію порівняння, яка викликається з qsort кожного разу, коли потрібно порівняти два значення.
Оскільки значення можуть мати будь-який тип, у функцію порівняння передаються два вказівники типу void* на елементи, що порівнюються.
Напишіть програму, яка досліджує, які вхідні дані є найгіршими для алгоритму швидкого сортування. Спробуйте знайти кілька масивів даних, які змушують qsort працювати якнайповільніше. Автоматизуйте процес експериментування так, щоб підбір і аналіз вхідних даних виконувалися самостійно.
Придумайте і реалізуйте набір тестів для перевірки правильності функції qsort.

## 

## Завдання 4
Виконайте наступну програму на мові програмування С:
int main() {
іnt pid;
pid = fork();
printf("%d\n", pid);
}
Завершіть цю програму. Припускаючи, що виклик fork() був успішним, яким може бути результат виконання цієї програми?

## 

## Завдання 5
Реалізуйте інтерпретатор команд, який підтримує черги читання-запису між процесами через pipe, не використовуючи shell.
## 
