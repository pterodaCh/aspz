
# Практика 8
## Завдання 1

Чи може виклик count = write(fd, buffer, nbytes); повернути в змінній count значення, відмінне від nbytes? Якщо так, то чому? Наведіть робочий приклад програми, яка демонструє вашу відповідь.
## 
Згідно з документацією freebsd системний виклик write(int fd, const void	*buf, size_t nbytes) намагається записати n байт даних в об'єкт на який посилається дескриптор fd з буферу, на який вказує buf. Як і зазначається у завданні, при успішному завершені виклику повинна повертатися кількість байт, що була записана. А з цього моменту починаються нюанси. Наприклад, при використанні неблокуючого вводу/виводу на таких об'єктах, як сокети або канали, які підлягають контролю потоку write() здатна записати менше байт, ніж було запитано. Або ж, на дисковому пристрої недостатньо місця для запису всього запитуваного байта! Тоді наступний виклик або передасть додаткові байти, або
може призвести до помилки.

Інші можливі причини виникнення помилки:
* Аргумент fd не є допустимим дескриптором, відкритим для запису
* Зроблено спробу записати у канал, що не відкритий для читання жодним процесом
* Здійснюється спроба запису в сокет типу SOCK_STREAM, який не підключено до однорангового сокету
* Вказівник, пов'язаний з fd, був від'ємним
* Файл було позначено для неблокуючого вводу/виводу, і жодні дані не могли бути записані негайно
* Значення nbytes більше за SSIZE_MAX (абобільше INT_MAX, якщо в sysctl debug.iosize_max_clamp не дорівнює нулю)

На мою думку, завдання пропонує створити ситуацію коли повернуться менша кількість nbytes. Ми можемо застосувати функцію [`fcntl()`](https://man.freebsd.org/cgi/man.cgi?query=fcntl&apropos=0&sektion=0&manpath=FreeBSD+7.2-RELEASE&format=html) із прапорцем `O_NONBLOCK`, який забезпечує неблокуючий ввід/вивід, та використати канали

## Завдання 2
Є файл, дескриптор якого — fd. Файл містить таку послідовність байтів: 4, 5, 2, 2, 3, 3, 7, 9, 1, 5. У програмі виконується наступна послідовність системних викликів:
lseek(fd, 3, SEEK_SET);
read(fd, &buffer, 4);
де виклик lseek переміщує показник на третій байт файлу. Що буде містити буфер після завершення виклику read? Наведіть робочий приклад програми, яка демонструє вашу відповідь.

## 
Системний виклик lseek() зміщує зміщення дескриптора файлу на зміщення аргументу відповідно до директиви whence.  Аргумент має бути відкритим дескриптором файлу.  Системний виклик lseek()змінює позицію вказівника на файл, пов'язаного з дескриптором файлу наступним чином
* SEEK_SET - зміщення (offset) встановлюється на offset байтів від початку файлу.
* SEEK_CUR - зміщення встановлюється на поточну позицію плюс offset байтів.
* SEEK_END - зміщення встановлюється на розмір файлу плюс offset байтів.
* SEEK_HOLE - зміщення встановлюється на початок наступного "дірки", що знаходиться на позиції не менше заданого offset.

«Дірка» визначається як нерозривний діапазон байт у файлі, всі з яких мають нульове значення, але не гарантується, що всі нулі
нульове значення, але не всі нулі у файлі гарантовано будуть
представлені як дірки, що повертаються з SEEK_HOLE. 
За умовою завдання цей фрагмент перемістить показник на третій байт файлу fd.

```
lseek(fd, 3, SEEK_SET)
```

І читає наступні 4 байти.

```
read(fd, &buffer, 4)
```

Таким чином ми отримуємо наступний результа:

![image](https://github.com/user-attachments/assets/89dcdf71-b6d3-4616-9923-7cf369094c32)

## Завдання 3 (Дуже цікаве завданння приділити більше часу коли приїду)
Бібліотечна функція qsort призначена для сортування даних будь-якого типу. Для її роботи необхідно підготувати функцію порівняння, яка викликається з qsort кожного разу, коли потрібно порівняти два значення.
Оскільки значення можуть мати будь-який тип, у функцію порівняння передаються два вказівники типу void* на елементи, що порівнюються.
Напишіть програму, яка досліджує, які вхідні дані є найгіршими для алгоритму швидкого сортування. Спробуйте знайти кілька масивів даних, які змушують qsort працювати якнайповільніше. Автоматизуйте процес експериментування так, щоб підбір і аналіз вхідних даних виконувалися самостійно.
Придумайте і реалізуйте набір тестів для перевірки правильності функції qsort.

## 
QuickSort - це алгоритм сортування, заснований на принципі «розділяй і володарюй», який вибирає елемент в якості стрижня і розділяє масив навколо вибраного стрижня, розміщуючи його в правильному положенні в відсортованому масиві. Він працює за принципом «розділяй і володарюй», розбиваючи проблему на менші підпроблеми

За часовою складністю він може варіюватися. Наприклад:
* Найкращий випадок: (Ω(n log n)), Виникає, коли стрижневий елемент ділить масив на дві рівні половини
* Середній випадок: (θ(n log n)), в середньому стрижневий елемент ділить масив на дві частини, але не обов'язково рівні
* Найгірший випадок: (O(n²)), Виникає, коли найменший або найбільший елемент завжди вибирається в якості стрижня 
Було вирішено провести дослідження на масивах,  різняться, що різняться як за розміром, так і структурою.

Були написані функції для генерації таких масивів:
* Випадковий
* Однакові елементи
* Сортований
* Зворотньо сортований
* Масив з певним патерном
* Погано стрижневий(чергування великого та малого числа)
* Органна труба
* Велика кількість дублікатів

Відповідно до результату дослідження можна побачити, що найгірше себе алгоритм проявив при сортуванні так званого `organpipe` або органної труби [(візуальне сортування)](https://youtu.be/M2u0o_9MeIY?si=YKRyzdgzjQku0HWA)
Особливість такої структури поягає в тому, що перша половина масиву зростає, а друга половина спадає. 

![image](https://github.com/user-attachments/assets/3825de69-6d09-4839-a101-a71db1be2caf)


## Завдання 4
Виконайте наступну програму на мові програмування С:
int main() {
іnt pid;
pid = fork();
printf("%d\n", pid);
}
Завершіть цю програму. Припускаючи, що виклик fork() був успішним, яким може бути результат виконання цієї програми?

## 
Функція fork() викликає створення нового процесу.  Новий процес (дочірній процес) є точною копією викликаючого процесу (батьківського процес). Обидва процеси мають однаковий код, але різне значення pid, що дозволяє відрізнити батьківський і дочірній процес. 

![image](https://github.com/user-attachments/assets/d1fe539e-939d-4e8c-9c27-a9071fe93a41)

1947 — pid, яке повертає fork() батьківському процесу
0 — значення, яке повертає fork() дочірньому процесу

## Завдання 5
Реалізуйте інтерпретатор команд, який підтримує черги читання-запису між процесами через pipe, не використовуючи shell.
## 
Після запуску інтерпретатор виводить запрошення до введення команди та чекає, поки користувач щось введе. Коли користувач введе `exit`, програма закінчиться і він перейде до стандарнтого shell. Якщо ж юзер вводить повноцінну команду або декілька команд, розділених `|`, рядок обробляється функцією парсингу. Вона розбиває введення на окремі підкоманди, які зберігаються у вигляді структури з аргументами та їхньою кількістю.
Нижче наведений приклад таких команд
```
ls -l
```

![image](https://github.com/user-attachments/assets/26959f87-0f83-48af-bb8f-7b87dab3c75e)

```
nano a.txt
```

![image](https://github.com/user-attachments/assets/67c32581-b5f1-4aa1-831e-f16a7cd9fadc)

```
uname -r
mkdir aaaaaaaa
```
![image](https://github.com/user-attachments/assets/d339fe0f-efaf-4ee3-b365-037965c5ba82)

```
./task5
exit
```

![image](https://github.com/user-attachments/assets/4220a11c-629b-46c2-9c9a-bf7c7ac41bef)


Найбільш цікавю тут є функція парсингу `parse_command_line(char *line, Command *commands, int *num_commands)`. Рядок розбивається на токени, які розділені пробілами. Якщо під час розбору зустрічається символ «|», парсер розуміє, що завершилася одна команда і починається інша. Кожна команда записується в масив структур `Command`, де зберігаються її аргументи. Таким чином формується список команд, який надалі виконується. На етапі виконання для кожної пари команд створюється канал. Потім створюються необхідні канали, дочірні процеси. Після цього всі неактуальні дескриптори pipe закриваються, і за допомогою execvp відбувається заміна поточного процесу на іншу програму.  `dup2` копіює файловий дескриптор канала на стандартний вхід (0) або стандартний вихід (1).
Потім всі  всі неактуальні дескриптори каналів закриваються.
