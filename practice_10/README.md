
# Практика 10
## Завдання з DumbShell

Фрагмент коду, що представлений у лекції реалізує просту командну оболонку (shell), яка дозволяє користувачу вводити команди та виконувати їх у дочірньому процесі. Програма зчитує команду від користувача, створюється новий процес за допомогою fork() далі програма виконує введену команду за допомогою execlp. У разі нвиконання виводиться повідомлення про помилку. Батьківський процес чекає на завершення дочірнього за допомогою wait(). Таким чином цей код реалізує базовий shell
Зберегти як dumbsh.c


Компілюємо код
```
gcc dumbsh.c -o dumbsh
```
Та запускаємо наступні команди
```
 ./dumbsh
dumbsh> ls
dumbsh> whoami
dumbsh> exit
```

![image](https://github.com/user-attachments/assets/49395f9f-5c54-4ec6-bf22-20db05360353)
## Завдання API wait — деталі
У лекції був додатковий фрагмент, який, як я зрозуміла, потрібно було додати до попереднього завдання, щоб переглянути та проаанлізувати результат.
```
#include <sys/wait.h>

int status;
pid_t pid = wait(&status);

if (WIFEXITED(status)) {
    printf("Exited with code %d\n", WEXITSTATUS(status));
}

```
Коли скомпілювати та запустити програму ми отримуємо наступний результат

![image](https://github.com/user-attachments/assets/595c7d83-1278-4b23-bbb4-ffde2efc6bd8)

Якщо ж детальніше розібратися відмінність, то у цій варіації коду використовуєтсяь не просто  wait(NULL), який не дає дізнатсия батьківському процесу про статус завершення дочірнього, а  більш точний виклик wait(&status) разом із перевіркою макросом WIFEXITED(status). Це дає краще зрозуміти потік програми, оскільки викоання з кодом 0 означає успішно, інші ж варіанти - з помилкою. 
## Fork bomb
У лекції був представлений фрагмент коду та примітка його не запускати(я і не збираюся але трішки детальінше про нього розповім)
```
:(){ :|:& };:
```

Вище написані якісь дуже не зрозуміли символи і перше, що приходить на думку - по клавіатурі потоптався кіт, але ні. Це є цілком валідний код, який ще й доволі небезпечний. Його називаються fork bomb або ще rabbit virus. Він призводить до вичерпання пам'яті вашого комп'ютера через нескінченне розгалуження процесу.

:() означає, що ви визначаєте функцію з назвою :
{:|: &} - це тіло функції :. Воно рекурсивно викликає функцію : і надсилає її вихідні дані іншому виклику функції :. А & означає, що створений процес має працювати у фоновому режимі.
Символ ; є розділювачем команд.
Фінальна : запускає функцію в перший раз.
По суті, ви створюєте функцію, яка викликає себе двічі при кожному виклику і не має можливості завершити роботу. Вона буде викликати себе двічі, доки у вас не закінчаться системні ресурси.

Його більш зрозумілий запис виглядає наступним чином.
```
fork() {
    fork | fork &
}
fork
```

Оскільки режим роботи fork bomb повністю полягає у створенні нових процесів, одним із способів запобігти впливу на всю систему є обмеження максимальної кількості процесів, якими може володіти один користувач. Цього можна досягти за допомогою утиліти `ulimit`
## Приклад створення кількох дітей
Дописавши невеликий фрагмент, а саме
```
for (int i = 0; i < 3; i++) {
    pid_t pid = fork();
    if (pid == 0) {
        printf("Child %d\n", i);
        exit(0);
    }
}
while (wait(NULL) > 0);
```
Створюютсья дочірні процеси та звершуються до початку роботи шела. Можемо переконатися:
![image](https://github.com/user-attachments/assets/e83cf678-e963-4547-a962-8f1f540892bd)

## Індивідуальне завдання 
Напишіть програму, в якій дочірній процес виводить свій PID та PID батьківського процесу, а потім завершується.
## 

![image](https://github.com/user-attachments/assets/e0f9cf84-5eea-4dc1-bb4c-02cf414502a2)

У попередніх практиках схоже завдання зустрічалося, проте можна описати його іще раз. Створюється новий процес за допомогою системного виклику fork(). Потім програма розгалужується на  батьківський та дочірній процеси. Дочірній процес має вивести на екран свій власний ідентифікатор процесу за допомогою getpid(), а також батьківсткий за допомогою функції getppid(). 
