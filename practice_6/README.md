# Практична 6
## Автоматичний компіляція та запуск програми докером 
Створіть Dockerfile, що автоматично встановлює Valgrind, компілює програму та запускає її під Valgrind.
## Виконання
У цій практичній роботі ми маємо можливість познайомитися із докером. Докер дозволяє збирати та виконувати програму у вільно відокремленому середовищі, відомому як контейнер. Ізоляція та безпека дозволяють працювати з декількома контейнерами на одному хості. Контейнери легкі і включають все необхідне для роботи програми, тому не доведеться покладатися на те, що встановлено на хості. Контейнери дають змогу отримувати однаковий результат роботи програму чи продукту в не залежності від системи отримувача.
Перейдім до виконня. Оскільки за умови завдання ми зобов'язані використати інструмент відлагодження `valgrind` - напишемо невелику програму на с із витоком пам'яті, щоб зафіксувати її за допомогою valgrind.
```
#include <stdlib.h>

int main() {
    char* string = malloc(5 * sizeof(char)); 
    return 0;
}
```
У цій програмі відсутня функція `free()` не очищується пам'ять, що виділяється за допомогою `malloc`. А це саме те що потрібно для тестування. Залишилося встановити докер. Для цього створюємом файл Dockerfile.
```
touch Dockerfile
```
Повністю вміст Dockerfile можна переглянути [тут](https://github.com/pterodaCh/aspz/blob/main/practice_6/Dockerfile). 

Пробіжім швиденько по його вмісту. Спершу задаємо образ докера. Образ контейнера - це стандартизований пакет, який містить усі файли, двійкові файли, бібліотеки та конфігурації для запуску контейнера.У нашому випадку це gcc. Далі виконуємо стандартнті команди: копіємо вміст [task1vasr2.c](https://github.com/pterodaCh/aspz/blob/main/practice_6/task1var2.c) у контейнер,оновлюємо пакети, качаємо valgrind та компілюємо скопійований файл.

Ця буде виконана при запуску контейнера.
```
CMD ["valgrind", "--leak-check=full", "--show-leak-kinds=all", "--track-origins=yes", "./task1var"]
```
Детальний опис прапорців:
* --leak-check=full — повна перевірка витоків пам’яті
* --show-leak-kinds=all — показ усіх типів витоків 
* --track-origins=yes — спроба знайти джерело витоків або помилок

Зашилишлося створити білд докера.

```
docker build -t dockeraspz .
```
![image](https://github.com/user-attachments/assets/7544c6ee-9164-4e70-9eca-f7a9b2c04bd4)

Білд успішний!

Запустім докер за допомогою цієї команди. У результаті цієї команди відразу має запустися файл [task1vasr2.c](https://github.com/pterodaCh/aspz/blob/main/practice_6/task1var2.c) із відлагодженням.

```
docker run --rm dockeraspz
```
![image](https://github.com/user-attachments/assets/c78d35ae-9e8e-4c28-8b83-f47c0ee57c39)

`Valgrind` успішно побачив витік пам'яті та вказав на неї.
